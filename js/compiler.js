/*
  This module accepts the parse tree generated by the parser,
  evaluates each item, and produces the output code to run in js with evaluator.
*/

var nativeFunctions = require('./native_functions');
var _ = require('../bower_components/lodash/dist/lodash');
var l = function(c) {
    console.log(c)
}
var throwIfFalse = function(test, msg) {
    if (!test) {
        throw {message: msg}
    }
    return test
}

exports.eval = function(tree) {
    var evalLeaf = function(leaf) {
        if (!leaf.type)
            return leaf;

        if (leaf.type === 'global') {
            return _.reduce(leaf.body, function(ac, node) {
                return ac + evalLeaf(node)
            }, "")
        }
        if (leaf.type === 'expression') {
            var lhs = throwIfFalse(leaf.body[0], "Expression had no function name (first part).")
            var rhs = throwIfFalse(leaf.body[2], "Expression had no arguments to evaluate the function with (second part).")
            return throwIfFalse(nativeFunctions.functions[evalLeaf(lhs)], 'No function by the name of ' + lhs)(evalLeaf(rhs))
        }
        if (leaf.type === 'hash') {
            var hash = {}
            var modf = function(x, i) {
                return i % 2 === 0
            }
            var keysAndVals = _.select(leaf.body, modf)
            var keys = _.select(keysAndVals, modf)
            var vals = _.select(keysAndVals,
                function(x, i) {
                    return i % 2 === 1
                });

            return "Object({" + _.reduce(_.zip(keys, vals),
                function(ac, pair) {
                    throwIfFalse(pair[0], "No lhs of hash")
                    throwIfFalse(pair[1], "No rhs of hash")
                    return ac.concat(evalLeaf(pair[0]) + ": " + evalLeaf(pair[1]))
                }, []).join(",") + "});"
        }
        return null;
    }

    return evalLeaf(tree)
}
